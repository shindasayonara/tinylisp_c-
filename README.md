# TinyLisp C++ 

## О проекте

Объектно-ориентированная версия интерпретатора Lisp на C++. Переписан с C на C++ для устранения проблем с глобальными переменными. Поддерживает создание нескольких независимых экземпляров интерпретатора.

## Особенности

- Полная инкапсуляция состояния интерпретатора в рамках класса TinyLisp
- Поддержка нескольких независимых экземпляров интерпретатора
- Совместимость с синтаксисом и семантикой оригинального tinylisp
- Реализация вычислительной модели eval–apply
- Поддержка замыканий и лексической области видимости
- Использование NaN-боксирования для компактного и эффективного представления данных
- Минималистичная архитектура без использования глобальных переменных  

## Архитектурные особенности

Интерпретатор реализован в виде самодостаточного класса TinyLisp, внутри которого инкапсулированы:
- управление памятью (cons-ячейки и строковая куча);
- таблица символов и встроенных примитивов;
- текущее лексическое окружение;
- состояние синтаксического анализатора.
Такой подход позволяет создавать несколько интерпретаторов с полностью изолированным состоянием, что невозможно в оригинальной реализации tinylisp на языке C.


## Структура файлов

- tinylisp.hpp — объявление класса TinyLisp и публичного интерфейса интерпретатора
- tinylisp.cpp — реализация вычислительного ядра, парсера и примитивных функций
- main.cpp — пример использования интерпретатора и REPL-оболочка

## Пример использования

```bash
// main.cpp
#include "tinylisp.hpp"
#include <iostream>
#include <vector>

int main() {
    TinyLisp lisp;

    std::cout << "=== TinyLisp C++ Translator ===\n" << std::endl;

    // Набор тестов (основан на dotcall.lisp)
    std::vector<std::string> tests = {
        "(define equal? (lambda (x y) (or (eq? x y) (and (pair? x) (pair? y) (equal? (car x) (car y)) (equal? (cdr x) (cdr y))))))",
        "(define list (lambda args args))",

        // Тест 1: + с точечной нотацией
        "(if (equal? ((lambda (l) (+ . l)) '(1 2 3)) 6) 'passed 'failed)",

        // Тест 2: -
        "(if (equal? ((lambda (l) (- . l)) '(1 2 3)) -4) 'passed 'failed)",

        // Тест 3: *
        "(if (equal? ((lambda (l) (* . l)) '(1 2 3)) 6) 'passed 'failed)",

        // Тест 4: let*
        "(if (equal? (let* (x 1) (y (+ 1 x)) (let* (z (+ x y)) z)) 3) 'passed 'failed)",

        // Тест 5: Currying
        "(if (equal? (((lambda (f x) (lambda args (f x . args))) + 1) 2 3) 6) 'passed 'failed)",

        // Тест 6: Caller dot
        "(if (equal? ((lambda (l) ((lambda (x y z) (list x y z)) '(1) '(2) . l)) '((3))) '((1) (2) (3))) 'passed 'failed)"
    };

    std::cout << "Running automated tests...\n";
    for (const auto& test : tests) {
        std::cout << "Test: " << test << "\nResult: ";
        try {
            std::cout << lisp.eval(test) << std::endl;
        }
        catch (const std::exception& e) {
            std::cout << "Runtime Error: " << e.what() << std::endl;
        }
        std::cout << "------------------------\n";
    }

    // Запуск REPL для ручного ввода
    std::cout << "\nStarting REPL (enter expressions):\n";
    lisp.repl();

    return 0;
}
```

## Реализованные возможности

- объектно-ориентированная архитектура интерпретатора;
- система вычислений eval / apply;
- поддержка списков и точечной нотации;
- замыкания и лексическая область видимости;
- встроенные примитивные функции;
- NaN-боксирование для представления значений Lisp;
- базовый сбор мусора, основанный на восстановлении состояния окружения;
- парсер S-выражений на основе рекурсивного спуска;
- механизм печати выражений Lisp.

## Назначение проекта

Проект выполнен в рамках курсовой работы и может использоваться:
- в учебных целях для изучения принципов работы интерпретаторов;
- для демонстрации вычислительной модели Lisp;
- как основа для дальнейших экспериментов с языками программирования;
- как встраиваемый интерпретатор в C++-приложениях.

## Лицензия

Проект основан на оригинальной реализации tinylisp
Автор оригинального проекта: Robert A. van Engelen

Реализация на C++ выполнена в учебных и исследовательских целях.
